Reflection Overview
- Java type representation
- Accessing a type's Class instance
- Accessing information about a type
- Accessing type member information
- Interacting with object instances
- Creating type instances
- Dynamic type loading


                                            Core capabilities of reflection
- Examine types at runtime
- Dynamically execute and access members

                                            The Need for Reflection
Apps do not always control types used
- Common in advanced app designs
- Common in tools and frameworks

Often dynamically load types
- Type not known at compile time
- There's no type-specific source code

Requires special runtime type handling
- Examine types at runtime
- Dynamically execute and access members

                                            Runtime Examination
Can fully examine object at runtime
- Type, Base types
- Interfaces implemented
- Members

Variety of uses
- Determine a type's capabilities
- Tools development
  - Type inspector/browser
  - Schema generation

                                            Dynamic Execution and Access
Can access full capability of type
- Construct instances
- Access fields
- Call Methods

Variety of uses
- Configurable application designs
  - Specifics tasks externally controlled
- Inversion of control application designs
  - App provides fundamental behavior
  - Classes added to specialize behavior

                                             Type as a Type
Type is the fundamental of any app solution
- We use types to model biz issues
- We use types to model tech issues

Java uses types to model type issues
- Fundamental type is the Class class
  - Each type has a Class instance
  - Describes the type in detail

e.g
Class Declaration

public class BankAccount{

    private final String id;
    private int balance = 0;

    public BankAccount(String id) {}
    public BankAccount(String id, int balance){}

    public String getId(){}
    public synchronized int getBalance(){}
    public synchronized void deposit(int amount) {}
    public synchronized void withdrawal(int amount){}
}

    BankAccount acct1 = new BankAccount("1234");
    BankAccount acct2 = new BankAccount("123", 500);


Java has internal Class class instance that corresponds to BankAccount class.
Class class instance is accessible at runtime.

Instance of Class class
simpleName
- BankAccount

Fields
- id
- balance

constructors
- BankAccount
- BankAccount

methods
- getId
- getBalance
- deposit
- withdrawal

                                        Accessing a Type's Class Instance
Accessing a type's Class instance
- From a type reference
  - Call getClass method
- From string name
  - Call Class.forName() static method
    - Pass fully qualified type name
- From type literal
  - Use typename.class

                                       Accessing Type Information

public final class HighVolumeAccount extends BankAccount implements Runnable{

  public HighVolumeAccount(String id) {super(id);}
  public HighVolumeAccount(String id, int balance) { super(id, balance); }

  private int[] readDailyDeposits(){...}
  private int[] readDailyWithdrawals(){...}

  public String run(){
    for(int depositAmt:readDailyDeposits())
    {
        deposit(depositAmt);
    }

    for(int withdrawalAmt:readDailyWithdrawls())
    {
        withdrawal(withdrawalAmt);
    }
  }
}

void classInfo(Object obj){
    Class<?> theClass = obj.getClass();
    System.out.println(theClass.getSimpleName());

    Class<?> superClass = theClass.getSuperclass();
    System.out.println(superClass.getSimpleName());

    Class<?>[] interfaces = theClass.getInterfaces();

    For(Class<?> interface interfaces)
    {
        System.out.println(interface.getSimpleName());
    }

    //Check to see if something is an interface - isInterface()
}



