1) Streams
2) Stream Errors and Cleanup
3) Chaining Streams
4) File and Buffered Steams
5) Accessing files with java.nio.file package
6) File Systems
7) Creating and Working with Zip file Systems

Streams:
    Stream is an ordered sequence of data. Provides a common I/O model.
types:
1) Byte streams: interact as binary data (01101110)
2) Text Streams: Interact as Unicode Characters (text)

example:

Reading One Byte at a Time

InputStream input = // create input stream
int intVal;

while((intVal = input.read()) >=0)
{
    byte byteVal = (byte) intVal;

    // do something with byte value
}

Reading One Character at a Time

Reader reader = // create reader instance
int intVal;

while((intVal = reader.read())>=0)
{
    char charVal = (char)intVal;

    "do something with charVal"
}

Reading Array of Bytes

InputStream input = // create input stream
int length;
byte[] byteBuff = new byte[10];
while((length = input.read(byteBuff)) >=0){

    for(int i=0; i<length; i++)
    {
        byte byteVal = byteBuff[i];

        //do something
    }

}

Reading Array of Characters

Reader reader = // create reader
int length;
char[] charBuff = new char[10];

while((length = reader.read(charBuff) >=0)
{
    for(int i = 0; i<length; i++){
    {

        char charVal = charBuff[i];

        //do something

    }
}


                            Writing
Writing Bytes:
OutputStream:

OutputStream output = // create output stream
byte byteVal = 100;
output.write(byteVal);

byte[] byteBuff = {0,63,127};
output.write(byteBuff);

Writing Characters:

Writer writer = // create writer

char charVal ='a';

writer.write(charVal);

char[] charBuff = {'a','b', 'c'};
writer.write(charBuff);

String stringVal = "Hello World";
writer.write(stringVal);


Common Input/OutputStream Derived Classes

                                   InputStream: abstract class - need implementation
                                                  |
   ByteArrayInputStream                   PipedInputStream                    FileInputStream



                                   OutputStream: abstract class - need implementation
                                                   |
   ByteArrayOutputStream                   PipedOutputStream                   FileOutputStream


Common Reader/Writer Derived Classes

                                   Reader: abstract class - need below implementation
                                                    |
 CharArrayReader                StringReader            PipedReader          InputStreamReader
                                                                                    |
                                                                                 FileReader


                                    Writer: abstract class - need below implementation
                                                     |
CharArrayWriter           StringWriter              PipedWriter              OutputStreamWriter
                                                                                     |
                                                                                 FileWriter


Stream Realities:
1) Error Handling: Stream methods throw exceptions to indicate errors
2) Cleanup: Cannot rely on standard java resource recovery

Cleanup:
Streams are backed by physical storage
- Often exist outside Java runtime
- Runtime may not reliably clean up

Providing reliable cleanup
- Streams implements Closable interface
  1) method: close()

Example:

Reader reader;

try{
    reader = //open reader
    //do something with reader
    }catch(IOException ex)
    {
    //handle exception
    }finally{
    //reader.close();    not that simple to do is properly do like below

    try{
       if(reader !=null)
       reader.close();
       }catch(IOException e2)
       {
            // handle exception
       }
    }

Automating Cleanup:
AutoClosable interface
- 1 Method: close()
- Base interface of Closable interface
- Provides support for try-with-resources

interface AutoClosable{
    void close() throws Exception;
 }

 interface Closable extends AutoClosable{
    void close() throws Exception;
 }

Try-with-resources:
 - Automates cleanup of 1 or more resources
 - A "resource" is any type that implements AutoClosable
 - Syntax similar to traditional try Statement
 - Optionally includes catch block(s)
  - Handle try body
  - Handle close method call


                                        Chaining Streams

Streams are often chained together
- One stream instance leverages other
- Creates higher-level functionality
- Simplifies re usability
- Chain using constructor

InputStreamReader leverages chaining
- Reader behavior over InputStream
- Character behavior over binary

Chaining Streams

void doChain(InputStream in) throws IOException{
    int length;
    char[] charBuff = new char[128];

    try(InputStreamReader reader = new InputStreamReader(in)){

    while((length = reader.read(charBuff))>=1)
    {
        //do something

    }
}

Classes available to simplify customization
- FilterReader, FilterWriter, FilterInputStream, FilterOutputStream
- abstract classes
- Methods call to contained stream methods
- Override only customized methods


                                        Buffered Streams

- Direct file access can be inefficient
- Buffered streams can improve efficiency
- Buffers content in memory
- Reduces underlying stream interaction

Buffering available for all 4 stream types
- BufferedReader
- BufferedWriter
- BufferedInputStream
- BufferedOutputStream

example:

try(BufferedReader br = new BufferedReader(new FileReader("*.txt"))
{
    int intVal;

    while((intVal = br.read())>=0)
    {
        char charVal = (char) intVal;
    }
}

Line breaks vary across platforms
- Unix
  \n (new line)
- Windows
  \r\n(carriage return & new line)

Buffered Streams add line break support
- Uses correct value for current platform
- BufferedWriter
  Generate line breaks: newLine()
- BufferedReader
  Line based read: readLine()

Example:
void writeData(String[] data) throws IOException{

try(BufferedWriter bw =
                   new BufferedWriter(new FileWriter("*.txt"))){

       for(String d: data)
       {
          bw.write(d);
          bw.newline();
       }

}

                        Reading Lines

void readData() throws IOException{

try(BufferedReader br =
            new BufferReader(new FileReader("*.txt"))){
        String intValue
      for((intValue = br.readLine()) !=null){
        System.out.println(inValue);
      }

}
}


Accessing Files with the java.nio.file package

java.nio.file preferred package for files
- java.io File xx streams are deprecated

Provides a number of benefits over java.io
- Better exception reporting
- Greater scalability
- More file system feature support
- Simplifies common tasks

Path:
- used to locate a file system item
- can be a file or a directory

Paths
- static path factory methods
- from string-based hierarchical path
- From URI

Path p1 = Paths.get("//document//data//foo.txt");
Path p2 = Paths.get("//document", "data", "foo.txt")

                                        Files Type
Files:
 - Static Methods for interacting with files
 - Create, Copy, Delete, etc.
 - Open File streams
   - newBufferedReader
   - newBufferedWriter
   - newInputStream
   - newOutputStream
 - Read/Write file contents
   - readAllLines
   - write

 Reading Lines with BufferedReader

 void readData() throws IOException{

    try(BufferedReader br =
                       Files.newBufferedReader(Path.get("data.txt"))){

        String inValue;
        while((inValue = br.readLine()) !=null)
        {
            System.out.println(inValue);

        }

    }

 }

Read All Lines

void readThemAll() throws IOException{
    List<String> lines =
                    Files.readAllLines(Paths.get("data.txt"));

    for(String line: lines)
    {
        System.out.println(line);
    }

}


File Systems:
Files are contained within a file system
- Has a default file system
- Specialized file systems are supported in java
  - Example: Zip file system
- Path instances are tied to file system
  - Paths class works only for default


File System Types
FileSystem:
- Represents an individual file system
- Factory for Path instances

FileSystems
- static FileSystem factory methods
- Open or create a file system
  - newFileSystem

Accessing File Systems

File System identified by URIs
- Specifics of URI vary greatly
- Zip file system uses "jar:file" scheme
  - jar:file:/emerys/data/bar.zip

File systems support custom properties
- Different for each file system type
- Examples
  - Whether to create if doesn't exit
  - String encoding






