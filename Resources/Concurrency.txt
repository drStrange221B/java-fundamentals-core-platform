Process
- Instance of a program/application
- Has resources such as memory, etc
- Has at least one thread

Thread
- Sequence of programmed instructions
- The thing that executes a program's code
- Utilizes process resources

                            A Simple Adder Class

class Adder{

    private String inFile, outFile;
    public Adder(String inFile, String outFile){ /* assign filename to member fields */}

    public void doAdd() throws IOException{
        int total = 0;
        String line = null;

        try(BufferedReader  reader = Files.newBufferedReader(Paths.get("inFile")))
        {
            while((line = reader.readLind()) !=null)
            {
                    total += Integer.parseInt(line);
            }

        }

        try(BufferedWriter writer = Files.newBufferedWriter(Paths.get(outFile))){
         {
            writer.write("Total: " + total);
         }

    }
    }

}


                                        Using Simple Adder Class
String[] inFiles = {"./file1.txt", .... "./file6.txt"};
String[] outFiles = {"./file1.out.txt", ... "./file6.txt"};

try{
    for(int i=0; i<inFiles.length; i++)
    {
        Adder adder = new Adder(inFiles[i], outFiles[i]);
        adder.doAdd();
    }

} catch(IOException e)
{
    // do something
}


                                        The Move to Multithreading
Multithreading is an explicit choice
- Must break the problem into parts
- Must handoff the parts for processing

Java provides differing levels of abstraction
- Supports very direct handling
  - Manual creation and co-ordination
- Supports higher level handling
  - Simplified creation and co-ordination


                                        Java Threading Foundation
Limited threading abstraction
- Very close to the standard OS behaviour
- Each thread started for a specific task
 - Terminates at end of task

Required explicit management
- Responsible to manage coordination

Exceptions tied to thread
- Each thread must handle own exceptions

                                        Threading Fundamental Types

Runnable interface
- Represents a task to be run on a thread
- Only member is the run method

Thread Class
- Represents a thread of execution
- Can interact with and effect thread state
- Begin execution with start method


                                        Adder with Threading Support
 class Adder implements Runnable{

    private String infile, outfile;

    public Adder(String inFile, String outFile){
        this.infile = infile;
        this.outfile = outfile;
    }

    public void doAdd() throws IOException{


    }

    public void run(){

        try{
            doAdd();

        }catch(IOException e){

           }

        }
    }
 }


                                            Running Adder on Separate Threads

String[] inFiles = {"./file1.txt", .... "./file6.txt"};
String[] outFiles = {"./file1.out.txt", .... "./file6.out.txt"};

try{

   for(int i = 0; i< inFiles.length; i++)
   {
        Adder adder = new Adder(inFiles[i], outFiles[i]);
        Thread thread = new Thread(adder);
        thread.start();
   }

}

problem with above code is that the main thread may finished its task before all other thread finished it task

solution: Introduce join()

String[] inFiles = {"./file1.txt", .... "./file6.txt"};
String[] outFiles = {"./file1.out.txt",..."./file6.txt"};

        Thread[] threads = new Thread[6];

try{

    for(int i=0; i<inFiles.length; i++){
        Adder adder = new Adder(inFiles[i], outFiles[i]);
        threads[i] = new Thread(adder);
        threads[i].start();
    }
}

    for(Thread thread: threads){

        thread.join();             // Blocks waiting for thread completion
    }


                                    Thread Management Details
Value of the Thread class
- Allows direct control over thread startup, shutdown, and coordination

Challenge of the Thread Class
- Responsible to efficiently manage thread startup, shutdown, and coordination
- Easily misused

                                    Abstracting Thread Management with Thread Pools
Java offers thread pools
- Creates a queue for tasks
- Assigns tasks into a pool of threads
- Handles details of managing threads


                                     Thread Pool Types
ExecutorService interface
- Models thread pool behavior
- Can submit tasks
- Request and wait for pool shutdown

Executors class
Methods for creating thread pools
- Dynamically sized pools
- Size limited pools
- pools that schedule tasks for later

                                     Running Adder in a Thread Pool
String[] inFiles = {"./file1.txt", .... "./file6.txt"};
String[] outFiles = {"./file1.out.txt", ... "./file6.out.txt"};

ExecutorService es = Executors.newFixedThreadPool(3);

for(int i = 0; i< inFiles.length; i++)
{
    Adder adder = new Adder(inFiles[i], outFiles[i]);
    es.submit(adder);
}

try {
    es.shutdown();
    es.awaitTermination(60, TimeUnit.SECONDS);
} catch(Exception e){

}

                                     Threading Relationship types
Callable interface
- Represents a task to be run on a thread
  - Can return results
  - Can throw exceptions
- Only member is the call method

Future interface
- Represents results a thread task
  - Returned by ExecutorService.submit
- The key method is get
  - Blocks until task completes
  - Returns Callable interface result
  - Throws Callable interface exception


                                     Adder Method Returning a Value

class Adder implements Callable<Integer>{

     private String inFile;

     public Adder(String inFile)
     {
        this.inFile = inFile;
     }

    public int doAdd() throws IOException{

    int total = 0;

    String line = null;

    try(BufferedReader reader = Files.newBufferedReader(Paths.get(inputFile))){

        while((line = reader.readLine())!=null)
        {
            total += Integer.parserInt(inLine);
        }
    }
       return total;
    }

    public int call() throws IOException
    {
           return doAdd();
    }
}



String[] inputFiles = {"./inputFile1.txt", ... "./inputFile6.txt"};
String[] outputFiles = {"./file.out1.txt", ... "./file.out6.txt"};

ExecutorService es = Executors.newFixedThreadPool(3);
Future<Integer>[] results = new Future<>[6] ;

for(int i=0; i<inputFiles.length; i++){

    Adder adder = new Adder(inFiles[i]);
   results[i] = es.submit(adder);
}

for(Future<Integer> future:results){

try{
    int value = future.get();
    }catch(ExecutionException e)
    {
         Throwable adderEx = e.getCause();

         System.out.println(e.getCause().getMessage());
    }catch(Exception e)
    {
         System.out.println(e.getMessage());
    }
}


                                   Concurrency Issues
The challenge of concurrency
- Threads sometimes share resources
- No problem if resources only read
- Changes must be coordinated

Failure to coordinate can create problems
- Receive wrong results
- Crash the program

                                   A Simple Bank Account Class
public class BankAccount{
    private int balance;

    public BankAccount(int startBalance){
        this.balance = startBalance;
    }

    public int getBalance(){
        return this.balance;
    }

    public void deposit(int amount){
        balance += amount;
    }
}


                                  A Class to Update the Bank Account
public class Worker implements Runnable{

    private BankAccount account;

    public Worker(BankAccount account){
        this.account = account;
    }

    public void run(){

        for(int i=0; i<10; i++){
            int startBalance = account.getBalance();
            account.deposit(10);
            int endBalance = account.getBalance();
        }
    }
}


                                   Running on Multiple Threads
ExecutorService es = Executors.newFixedThreadPool(5);
BankAccount account = new BankAccount(100);

for(int i=0; i<5; i++)
{
   es.submit(new Worker(account));
}

expected end balance = 600 but this could by less or way less than 600 Due to the unexpected behaviour of
thread coordination.
this usually happens when there are non atomic operation e.g. balance += amount;  is not atomic
adding balance takes place in three steps
1) read balance from memory  (Read current value from memory)
2) increase balance  (Perform addition)
3) update value in memory  (Write result back to memory)

At any point the thread scheduler could switch between threads which caused the data corruption. i.e
wrong values get updated.

                                    Coordinating Method Access
Synchronized methods
- Coordinate thread access to methods
- User synchronized method modifier
  - Class can have as many as needed

Synchronization managed per instance
- No more than one thread can be in any synchronized method at a time.


                                    Using Synchronized Methods
When to use synchronized
- Protect modification by multiple threads
- Reading value that might be modified by another thread

Why not always synchronize methods
- Has significant overhead
- Use only in multithreading scenarios

Constructors are never synchronized
- A given object instance always created on exactly one thread


                                    Synchronized Methods on Bank Account Class

 public class BankAccount{
     private int balance;

     public BankAccount(int startBalance){
         this.balance = startBalance;
     }

     public synchronized int getBalance(){
        return balance;
     }

     public synchronized void deposit(int amount){
        balance += amount;
     }
}

                                      Manual Synchronization
Synchronized methods
- Automated concurrency management
- Used lock of current object instance

All java objects have a lock
- Can manually acquire that lock
  - Use synchronized statement block
  - Available to any code with a reference


                                    Synchronized Statement Block

class BankAccount{
   private int balance;

   public void deposit(int amount){
         balance +=amount;
   }
}


class Worker implements Runnable{
    private BankAccount account;

    public void run(){

        for(int i<0; i<10; i++)
        {
            synchronized(account){
                account.deposit(10);
            }
        }
    }
}


                                    Why Use Synchronized Statement Blocks
Synchronized blocks provide flexibility
- Enables use of non-thread safe classes
- Can protect complex blocks of code
- Sometimes synchronized methods just aren't enough


                                    Concurrency Safe Collection Access
Synchronized collection wrappers
- Most collections are not thread safe
- Can create thread safe wrapper
  - Use Collection class static methods
    - synchronizedList
    - synchronizedMap
    - Etc
- Wrapper is a thread safe proxy
  - Actual work occurs in original object


                                    Blocking Collections
Coordinating producers and consumers
- One or more threads produce content
- One or more other threads consume
  - Must wait for content if not available

Java provides blocking queues
- Attempt to read blocks if empty
  - Wakes up when content available
- Examples
  - LinkedBlockingQueue
  - PriorityBlockingQueue
  - Etc.


                                       Java Provides Still More
java.util.concurrent
- Types for managing concurrency
  - Has much of what we've talked about
- Semaphores
  - Coordinate access to multiple resources
- Lots more

java.util.concurrent.atomic
- Types provides atomic operations
  - set, get, getAndAdd, compareAndSet


                                        Summary
Thread class
- Represents a thread of execution
- Similar to most OS thread representations
- Responsible to handle most details

Runnable interface
- Represents a task to run on a thread
- Simply override run method
- Can't return results
- Exceptions responsibility of thread

ExecutorService
- Abstracts thread management details
- Can interact with thread pools

Callable interface
- Represents a task to be run on a thread
- Can return results
- Can throw exceptions

Future interface
- Represents results of a thread task
- Can access results from task

All java objects have a lock
- Can access with synchronized methods
  - Acquires lock of target instance of call
  - Only one active at a time on an object
- Can manually acquire lock
  - Use synchronized statement block
  - Available to any code referencing object

